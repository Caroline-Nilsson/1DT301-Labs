The first thing we need to do is, as described above, to initialize the stack pointer. This is done by setting \texttt{SP} to the end of SRAM (\texttt{RAMEND}). Since \texttt{SP} is a 16-bit register we need to set both \texttt{SPL} and \texttt{SPH}. \texttt{SPL} is set to the least significant 8 bits of \texttt{RAMEND} and \texttt{SPH} is set to the most significant 8 bits of \texttt{RAMEND}. As always, we also set \texttt{PORTB} as output so we can write values to the LEDs.

The main part of the program consists of a loop where the current LED state is first written to the LEDs. We then delay execution of the program for \textasciitilde $0.5$ seconds and finally rotate the bits in the LED state to the left using the \texttt{rol} instruction. 

The delay functionality is as described in the assignment description implemented in a subroutine which we have calculated using the \emph{AVR Delay Loop Calculator}\footnote{http://www.bretmulvey.com/avrdelay.html}. We have modified the subroutine slightly by pushing the registers that are used in it to the stack at the start of the subroutine and popping them before returning. This is done so we don't accidentally overwrite any values in the registers that the subroutine is using.

As with the other assignments, when we tested the code on hardware we had to adjust it to handle the pull-up resistor on \texttt{PORTB}.
