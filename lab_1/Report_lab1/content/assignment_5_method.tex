The first thing we needed to do, as described above, was to initialize the stack pointer. This is done by setting \texttt{SP} to the end of SRAM (\texttt{RAMEND}). Since \texttt{SP} is a 16-bit register we needed to set both \texttt{SPL} and \texttt{SPH}. \texttt{SPL} is set to the least significant 8 bits of \texttt{RAMEND} and \texttt{SPH} is set to the most significant 8 bits of \texttt{RAMEND}. As always, we also set \texttt{PORTB} as output so we can write values to the LEDs.

The main part of the program consists of a loop where the current LED state is first written to the LEDs. We then delay execution of the program for \textasciitilde $0.5$ seconds and finally rotate the bits in the LED state to the left using the \texttt{rol} instruction. 

The delay functionality is as described in the assignment description implemented in a subroutine which we have calculated using the \emph{AVR Delay Loop Calculator}.\footnote{http://www.bretmulvey.com/avrdelay.html} We calculated a delay of 500 ms for 1.0 MHz, which is the default clock speed of the AVR ATmega2560.\footnote{\emph{Atmel ATmega640/V-1280/V-1281/V-2560/V-2561/V DATASHEET}, Atmel Corporation, San Jose, CA, 2014, pp. 40} We have modified the subroutine slightly to push the registers that are used in it to the stack at the start of the subroutine and pop them before returning. This is done so we do not accidentally overwrite any values in the registers that the subroutine is using. These additional instructions do of course make the delay slightly longer, particularly since the CPU will need to write to and read from SRAM, but we did not think that mattered that much in this case.

As with the other assignments, when we tested the code on hardware we had to adjust it to handle the pull-up resistor on \texttt{PORTB}.
