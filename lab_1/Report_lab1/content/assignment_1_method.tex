The pseudocode (see algorithm \ref{assign1.pseudo}) and the flowchart (see figure \ref{assign1.flow}) shows that we first set \texttt{PORTB} as an output port. To light up \texttt{LED2} we then only need to write a value to the bit on \texttt{PORTB} that corresponds to \texttt{LED2}. 

We started with the assumption that all bits in \texttt{PORTB} would be zero when the LEDs where turned off and as such wrote a 1 to the third least significant bit to light up \texttt{LED2}. When we tested the program on the hardware however, all LEDs except \texttt{LED2} was turned on. If we understood this correctly, this was due to the pull-up resistor being activated on \texttt{PORTB} which made the LEDs light when their bit was 0 (as opposed to 1) on \texttt{PORTB}. We fixed this by simply inverting the value we wrote to \texttt{PORTB} (${1111\ 1011}_2$ instead of ${0000\ 0100}_2$).

The minimal number of lines required to write this program we think are 4 (unless there is some obscure trick). 2 lines are required to set the LED port as output: 1) write a value to a register and 2) write that value to the data direction register, and 2 lines for turning on the LED: 3) write the LED state to a register and 4) write the LED state to the output port. One could try to write the program in 3 lines, by reusing the value written to the data direction register when writing to the output port. But in this case the LED will not turn on because of the pull-up resistor will require that a zero is written to the bit corresponding to the LED that we want to light.
