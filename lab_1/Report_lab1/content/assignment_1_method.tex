The pseudocode (see algorithm \ref{assign1.pseudo}) and the flowchart (see figure \ref{assign1.flow}) shows that we first set \texttt{PORTB} as an output port. To light up \texttt{LED2} we then only need to write a value to the bit on \texttt{PORTB} that corresponds to \texttt{LED2}. 

We started with the assumption that all bits in \texttt{PORTB} would be zero when the LEDs where turned off and as such wrote a 1 to the third least significant bit to light up \texttt{LED2}. When we tested the program on the hardware however, all LEDs except \texttt{LED2} was turned on. If we understood this correctly, this was due to the pull-up resistor being activated on \texttt{PORTB} which made the LEDs light when their bit was 0 (as opposed to 1) on \texttt{PORTB}. We fixed this by simply inverting the value we wrote to \texttt{PORTB} (${1111\ 1011}_2$ instead of ${0000\ 0100}_2$).

The minimal number of lines required to write this program we think are four. Two lines are required to set the LED port as output: one to write a value to a register and the other to write that value to the data direction register. The final two lines are for turning on the LED: one to write the LED state to a register and the other to write the LED state to the output port. One could try to write the program in three lines, by reusing the value written to the data direction register when writing to the output port. But in this case the LED will not turn on because of the pull-up resistor which will require that a zero is written to the bit corresponding to the LED that we want to light.
