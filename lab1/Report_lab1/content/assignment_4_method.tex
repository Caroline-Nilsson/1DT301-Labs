First, we needed to setup the debugger to run the program on the simulator which is done by selecting "Simulator" in \emph{Project} $\rightarrow$ \emph{Properties} $\rightarrow$ \emph{Tool}. To start stepping through the program we then clicked \emph{Debug} $\rightarrow$ \emph{Start debugging and break}. To be able to see what happens in the simulator as the program runs, we opened the \emph{Processor Status} and \emph{I/O} windows by clicking on their respective icons. Finally, because values from the pins on the switches have a default value of 1 we needed to set all \texttt{PINC} bits, which we did by selecting \emph{I/O Port (PORTC)} in the I/O window and filling in the bits to the right of \emph{PINC} by clicking on them.

We then started stepping through the program. The first few lines sets \texttt{PORTB} as output (line 42-43) and \texttt{PORTC} to input (line 46-47) and this can be seen in the simulator by keeping an eye on \emph{PORTB $\rightarrow$ DDRB}, which bits are set to 1, and \emph{PORTC $\rightarrow$ DDRC}, which are set to 0, as the debugger executes the instructions. When the debugger executes line 50, which sets all bits in register 17, we can see this in the Processor Status window in that \emph{r17} gets set to \texttt{0xFF}. We tested that the instruction on line 53, which checks if \texttt{SW5} is pressed down, works by manually clearing bit 5 on PINC through the I/O window. The instruction that gets executed if this is true, can be seen in the simulator in that register 17 changes value from \texttt{0xFF} to \texttt{0xFE}. The result of line 56, which writes the value of register 17 to \texttt{PORTB}, can be seen by clicking on PORTB in the I/O window where the bits next to PORTB and PINB are updated accordingly. We could also see that the \emph{Program Counter} value in the Processor Status window gets updated when the final line \texttt{rcall loop} gets executed.
